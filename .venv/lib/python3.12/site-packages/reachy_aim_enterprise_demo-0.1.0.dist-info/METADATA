Metadata-Version: 2.4
Name: reachy-aim-enterprise-demo
Version: 0.1.0
Summary: Reachy Mini Lite enterprise demo skeleton: edge client + OpenAI-compatible AIM + Helm add-ons
License: Apache-2.0
Requires-Python: >=3.10
Description-Content-Type: text/markdown
Requires-Dist: requests>=2.32.0
Requires-Dist: python-dotenv>=1.0.1
Requires-Dist: typer>=0.12.3
Requires-Dist: rich>=13.7.1
Requires-Dist: pydantic>=2.7.0
Requires-Dist: prometheus-client>=0.20.0

# Reachy Mini Lite + AIM (OpenAI-compatible) Enterprise Demo

This repo provides a **fully functional** enterprise demo that connects a Reachy Mini robot to an AIM (OpenAI-compatible) endpoint. You can run it **without the physical robot** using the Reachy Mini daemon simulation, while targeting a real **AIM OpenAI-compatible endpoint** (e.g., running on MI300X in your datacenter).

## What you get
- **Edge client** (runs on your Strix Halo host): CLI orchestrator + AIM client + Prometheus metrics
- **Reachy Mini integration** via daemon URL (simulation-friendly, ready for hardware)
- **Helm chart** (`helm/reachy-demo-addons`) for cluster-side demo add-ons:
  - Load generator CronJob (triggerable as a Job)
  - Optional Ingress (disabled by default)
  - Grafana dashboard JSON shipped as a ConfigMap
  - Optional dependency wiring for `kube-prometheus-stack` (disabled by default)

## Prerequisites

- Python 3.10 or higher
- `pip` and `venv` (usually included with Python)
- Access to an AIM (OpenAI-compatible) endpoint
- (Optional) `helm` for Kubernetes deployment
- (Optional) `reachy-mini[mujoco]` for local simulation testing

## Quick Start Guide

Follow these steps to test the code locally:

### Step 1: Set up Python environment

```bash
# Create virtual environment
python3 -m venv .venv

# Activate virtual environment
source .venv/bin/activate

# Upgrade pip
pip install -U pip

# Install the package and dependencies
pip install -e .
```

**Verify installation:**
```bash
# Check that the command is available
python -m reachy_demo.main --help
```

### Step 2: Configure environment variables

```bash
# Copy the example environment file
cp .env.example .env

# Edit .env and set your AIM endpoint URL
# REQUIRED: Set AIM_BASE_URL to your AIM endpoint
# Example: AIM_BASE_URL=http://127.0.0.1:8000
# Or: AIM_BASE_URL=https://your-aim-endpoint.example.com
```

**Edit `.env` file:**
- Set `AIM_BASE_URL` (required) - your AIM endpoint URL
  - For local testing with port-forward: `http://127.0.0.1:8000`
  - For remote endpoint: `https://<your-ingress-host>`
- (Optional) Adjust `AIM_MODEL` if different from `llm-prod`
- (Optional) Set `AIM_API_KEY` if your endpoint requires authentication

### Step 3: (Optional) Run Reachy Mini daemon in simulation

If you want to test with the Reachy Mini daemon simulation, open a **new terminal**:

```bash
# Activate the same virtual environment
source .venv/bin/activate

# Install reachy-mini with mujoco support
pip install "reachy-mini[mujoco]"

# Start the daemon in simulation mode
reachy-mini-daemon --sim
```

**Verify daemon is running:**
- Open http://localhost:8000/docs in your browser
- You should see the API documentation

**Note:** The demo will work even if the daemon is not running (it will show a warning and continue).

### Step 4: Run the edge demo

In your main terminal (with virtual environment activated):

```bash
# Make sure virtual environment is activated
source .venv/bin/activate

# Run the interactive demo
python -m reachy_demo.main run
```

**What to expect:**
1. You'll see a welcome message and metrics URL
2. Type a prompt and press Enter
3. The app will:
   - Send your prompt to the AIM endpoint
   - Display the model's response
   - Show latency metrics (AIM call time, end-to-end time, SLO status)
   - Attempt to trigger a robot gesture (placeholder in sim mode)

**Example interaction:**
```
You> What is machine learning?
[AIM response appears in a panel with latency metrics]
```

**To exit:** Press `Ctrl+C`

### Step 5: (Optional) Check Prometheus metrics

While the demo is running, you can view metrics in another terminal:

```bash
# View metrics endpoint
curl http://127.0.0.1:9100/metrics
```

Or open in browser: http://127.0.0.1:9100/metrics

**Available metrics:**
- `edge_e2e_ms` - End-to-end latency histogram
- `aim_call_ms` - AIM API call latency histogram
- `edge_requests_total` - Total request counter
- `edge_errors_total` - Error counter
- `edge_slo_miss_total` - SLO violation counter

### Step 6: (Optional) Test local load generator

You can also run a local load test:

```bash
# Activate virtual environment
source .venv/bin/activate

# Run load generator (8 concurrent workers, 30 seconds)
python -m reachy_demo.tools.loadgen_local run --concurrency 8 --duration-s 30
```

This will send concurrent requests to your AIM endpoint and display latency statistics (p50, p95, mean).

## Testing the Code

### Quick Test (Without AIM Endpoint)

To verify the code structure and imports work correctly:

```bash
# Activate virtual environment
source .venv/bin/activate

# Test configuration loading (will fail without AIM_BASE_URL, which is expected)
python -c "from reachy_demo.config import load_settings; print('Config module OK')" 2>&1 || echo "Expected: AIM_BASE_URL required"

# Test with environment variable
AIM_BASE_URL=http://test.example.com python -c "from reachy_demo.config import load_settings; s = load_settings(); print(f'Config loaded: {s.aim_base_url}')"

# Test imports
python -c "from reachy_demo.aim.client import AIMClient; from reachy_demo.orchestrator.loop import run_interactive_loop; print('All imports successful')"
```

### Full Integration Test

1. **Set up environment** (Steps 1-2 above)
2. **Configure AIM endpoint** in `.env`
3. **Run the demo** (Step 4 above)
4. **Verify metrics** (Step 5 above)

### Troubleshooting

**Issue: "AIM_BASE_URL is required"**
- Solution: Make sure you've created `.env` from `.env.example` and set `AIM_BASE_URL`

**Issue: "ModuleNotFoundError: No module named 'dotenv'"**
- Solution: Make sure you've activated the virtual environment and run `pip install -e .`

**Issue: "Connection refused" or timeout errors**
- Solution: Verify your `AIM_BASE_URL` is correct and the endpoint is accessible
- Check network connectivity: `curl $AIM_BASE_URL/health` (if health endpoint exists)

**Issue: "Reachy daemon not reachable" warning**
- This is expected if you're not running the daemon. The demo will continue without robot control.

## Cluster Deployment via Helm

This Helm chart is **not for installing a Kubernetes cluster** on your host.
It installs **demo add-ons in your existing Kubernetes cluster** (loadgen, optional ingress, dashboard configmap).

### Prerequisites

- Kubernetes cluster with `kubectl` configured
- `helm` 3.x installed
- Access to the cluster where AIM endpoint is running

### Installation Steps

**Step 1: Update Helm dependencies (if using optional monitoring)**
```bash
cd helm/reachy-demo-addons
helm dependency update
cd ../..
```

**Step 2: Install the chart**
```bash
helm upgrade --install reachy-demo \
  helm/reachy-demo-addons \
  -n reachy-demo \
  --create-namespace \
  --set aim.baseUrl="http://aim.default.svc.cluster.local:8000" \
  --set aim.model="llm-prod"
```

**Customize values:**
- Edit `helm/reachy-demo-addons/values.yaml` or use `--set` flags
- Common customizations:
  - `aim.baseUrl` - Your AIM service URL in cluster
  - `aim.model` - Model name to use
  - `loadgen.schedule` - Cron schedule for load generator
  - `loadgen.concurrency` - Number of concurrent workers

**Step 3: Verify installation**
```bash
# Check resources
kubectl -n reachy-demo get all

# Check CronJob
kubectl -n reachy-demo get cronjob
```

### Trigger Load Generator Manually

The load generator runs on a schedule, but you can trigger it manually:

```bash
# Create a one-off job from the CronJob
kubectl -n reachy-demo create job --from=cronjob/reachy-demo-addons-loadgen reachy-demo-loadgen-manual

# Watch the logs
kubectl -n reachy-demo logs -f job/reachy-demo-loadgen-manual
```

**Expected output:** Statistics showing request count, p50, p95, and mean latency.

## Project Structure

```
reachy-aim-enterprise-demo/
├── src/reachy_demo/          # Main Python package
│   ├── main.py               # CLI entry point
│   ├── config.py             # Configuration management
│   ├── aim/                  # AIM client (OpenAI-compatible)
│   │   ├── client.py         # HTTP client with retries
│   │   ├── models.py         # Pydantic models
│   │   └── errors.py          # Error handling
│   ├── adapters/             # Robot abstraction layer
│   │   ├── robot_base.py     # Abstract base class
│   │   ├── robot_rest.py     # REST adapter (implements health/state)
│   │   └── robot_sim.py      # Simulation mode alias
│   ├── orchestrator/         # Main interaction loop
│   │   ├── loop.py           # Interactive conversation loop
│   │   └── prompts.py        # System prompts
│   ├── obs/                  # Observability
│   │   └── metrics.py        # Prometheus metrics
│   └── tools/                # Utilities
│       └── loadgen_local.py  # Local load generator
├── helm/reachy-demo-addons/  # Kubernetes Helm chart
│   ├── Chart.yaml            # Chart metadata
│   ├── values.yaml           # Default values
│   └── templates/            # Kubernetes manifests
├── tests/                    # Test suite
├── .env.example              # Environment variable template
├── Makefile                  # Convenience commands
├── pyproject.toml            # Python package config
└── README.md                # This file
```

## Implementation Status

✅ **Fully Implemented:**
- AIM client with retry logic and error handling
- Interactive conversation loop with context management
- Prometheus metrics collection and export
- Configuration management with environment variables
- Local and Kubernetes load generators
- Helm charts for cluster deployment
- Robot health checks and state queries

⚠️ **Placeholders (intentional, documented):**
- `gesture()` method - No-op placeholder (waiting for physical robot endpoints)
- `speak()` method - No-op placeholder (waiting for TTS/audio integration)

These placeholders are intentionally safe no-ops and won't cause errors. The code gracefully handles them.

## Configuration Reference

### Environment Variables

| Variable | Required | Default | Description |
|----------|----------|---------|-------------|
| `AIM_BASE_URL` | ✅ Yes | - | AIM endpoint URL (e.g., `http://127.0.0.1:8000`) |
| `AIM_CHAT_PATH` | No | `/v1/chat/completions` | Chat completions API path |
| `AIM_MODEL` | No | `llm-prod` | Model name to use |
| `AIM_API_KEY` | No | - | API key for authentication |
| `AIM_TIMEOUT_MS` | No | `2200` | Request timeout in milliseconds |
| `AIM_MAX_RETRIES` | No | `1` | Maximum retry attempts |
| `REACHY_DAEMON_URL` | No | `http://127.0.0.1:8000` | Reachy Mini daemon URL |
| `ROBOT_MODE` | No | `sim` | Robot mode: `sim` or `hardware` |
| `E2E_SLO_MS` | No | `2500` | End-to-end SLO in milliseconds |
| `EDGE_METRICS_HOST` | No | `127.0.0.1` | Metrics server host |
| `EDGE_METRICS_PORT` | No | `9100` | Metrics server port |

## Next Steps When Physical Robot Arrives

1. **Connect to physical robot:**
   ```bash
   # Run daemon with serial port instead of simulation
   reachy-mini-daemon -p /dev/ttyUSB0  # or your serial port
   ```

2. **Implement gesture endpoint:**
   - Review daemon API docs at `http://localhost:8000/docs`
   - Update `src/reachy_demo/adapters/robot_rest.py`
   - Implement `gesture()` method with actual API calls

3. **Implement speech:**
   - Wire `speak()` method to TTS service or device audio
   - Update `src/reachy_demo/adapters/robot_rest.py`

## Additional Notes

- **Reachy Mini daemon:** Exposes a REST API (docs at `/docs`). The current adapter implements health checks and state queries. Motion endpoints can be added once validated.
- **AIM API key:** Optional. If required, set `AIM_API_KEY` in `.env` and enable `loadgen.apiKey.enabled=true` in Helm values.
- **Metrics:** Edge metrics are exposed at `http://127.0.0.1:9100/metrics` by default. Use Prometheus to scrape and Grafana to visualize.
- **Load testing:** Both local (`loadgen_local.py`) and Kubernetes (CronJob) load generators are available.

## License

Apache-2.0 (recommended; change as needed).
